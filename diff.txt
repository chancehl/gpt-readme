diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..0b745e2
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+/target
+.env
\ No newline at end of file
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 0000000..3b47842
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,13 @@
+[package]
+name = "gpt-readme"
+version = "0.1.0"
+edition = "2021"
+
+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
+
+[dependencies]
+dotenv = "0.15.0"
+reqwest = { version = "0.11.23", features = ["json"] }
+serde = { version = "1.0.196", features = ["derive"] }
+serde_json = "1.0.112"
+tokio = { version = "1.35.1", features = ["full"] }
diff --git a/diff.txt b/diff.txt
new file mode 100644
index 0000000..b53609d
--- /dev/null
+++ b/diff.txt
@@ -0,0 +1,85 @@
+diff --git a/.gitignore b/.gitignore
+new file mode 100644
+index 0000000..ea8c4bf
+--- /dev/null
++++ b/.gitignore
+@@ -0,0 +1 @@
++/target
+diff --git a/Cargo.toml b/Cargo.toml
+new file mode 100644
+index 0000000..7280967
+--- /dev/null
++++ b/Cargo.toml
+@@ -0,0 +1,12 @@
++[package]
++name = "gpt-readme"
++version = "0.1.0"
++edition = "2021"
++
++# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
++
++[dependencies]
++reqwest = { version = "0.11.23", features = ["json"] }
++serde = { version = "1.0.196", features = ["derive"] }
++serde_json = "1.0.112"
++tokio = { version = "1.35.1", features = ["full"] }
+diff --git a/src/main.rs b/src/main.rs
+new file mode 100644
+index 0000000..2b62e08
+--- /dev/null
++++ b/src/main.rs
+@@ -0,0 +1,54 @@
++use serde::{Deserialize, Serialize};
++// use std::error::Error;
++use reqwest::Error;
++
++extern crate reqwest;
++
++#[derive(Serialize, Deserialize)]
++struct GitDiff {
++    diff: String,
++}
++
++#[derive(Serialize, Deserialize)]
++struct ChatGPTRequest {
++    git_diff: GitDiff,
++}
++
++#[derive(Serialize, Deserialize)]
++struct ChatGPTResponse {
++    readme: String,
++}
++
++async fn generate_readme(git_diff: GitDiff) -> Result<String, Error> {
++    let api_url = "";
++
++    let client = reqwest::Client::new();
++
++    let request = ChatGPTRequest { git_diff };
++
++    let response = client.post(api_url).json(&request).send().await?;
++
++    if response.status().is_success() {
++        let response_data: ChatGPTResponse = response.json().await?;
++
++        Ok(response_data.readme)
++    } else {
++        Err(response.error_for_status().unwrap_err())
++    }
++}
++
++#[tokio::main]
++async fn main() {
++    let git_diff = GitDiff {
++        diff: "TODO".to_owned(),
++    };
++
++    match generate_readme(git_diff).await {
++        Ok(readme) => {
++            println!("{}", readme)
++        }
++        Err(error) => {
++            eprintln!("{}", error)
++        }
++    }
++}
diff --git a/src/main.rs b/src/main.rs
new file mode 100644
index 0000000..3d633a4
--- /dev/null
+++ b/src/main.rs
@@ -0,0 +1,119 @@
+use dotenv::dotenv;
+use reqwest::{Client, Error};
+use serde::{Deserialize, Serialize};
+use std::{collections::HashMap, env};
+
+#[derive(Serialize, Deserialize)]
+struct Root {
+    model: String,
+    messages: Vec<Message>,
+    tools: Vec<Tool>,
+    tool_choice: String,
+}
+
+#[derive(Serialize, Deserialize)]
+struct Message {
+    role: String,
+    content: String,
+}
+
+#[derive(Serialize, Deserialize)]
+struct Tool {
+    #[serde(rename = "type")]
+    tool_type: String,
+    function: Function,
+}
+
+#[derive(Serialize, Deserialize)]
+struct Function {
+    name: String,
+    description: String,
+    parameters: Parameters,
+}
+
+#[derive(Serialize, Deserialize)]
+struct Parameters {
+    #[serde(rename = "type")]
+    param_type: String,
+    properties: HashMap<String, Property>,
+    required: Vec<String>,
+}
+
+#[derive(Serialize, Deserialize)]
+struct Property {
+    #[serde(rename = "type")]
+    property_type: String,
+    description: Option<String>,
+    #[serde(rename = "enum")]
+    enum_values: Option<Vec<String>>,
+}
+
+#[tokio::main]
+async fn main() -> Result<(), Error> {
+    dotenv().ok();
+
+    let openai_api_key = env::var("OPENAI_API_KEY").expect("OPENAI_API_KEY not set");
+
+    let client = Client::new();
+
+    let message = Message {
+        role: "user".to_string(),
+        content: "What is the weather like in Boston?".to_string(),
+    };
+
+    let function_parameters = Parameters {
+        param_type: "object".to_string(),
+        properties: {
+            let mut properties = HashMap::new();
+
+            properties.insert(
+                "diff".to_string(),
+                Property {
+                    property_type: "string".to_string(),
+                    description: Some(
+                        "The output of the git diff command for a given repository".to_string(),
+                    ),
+                    enum_values: None,
+                },
+            );
+
+            properties
+        },
+        required: vec!["diff".to_string()],
+    };
+
+    let tool_function = Function {
+        name: "get_current_weather".to_string(),
+        description: "Get the current weather in a given location".to_string(),
+        parameters: function_parameters,
+    };
+
+    let tool = Tool {
+        tool_type: "function".to_string(),
+        function: tool_function,
+    };
+
+    let body = Root {
+        model: "gpt-3.5-turbo".to_string(),
+        messages: vec![message],
+        tools: vec![tool],
+        tool_choice: "auto".to_string(),
+    };
+
+    let response = client
+        .post("https://api.openai.com/v1/chat/completions")
+        .header("Content-Type", "application/json")
+        .header("Authorization", format!("Bearer {}", openai_api_key))
+        .json(&body)
+        .send()
+        .await?;
+
+    println!("Status: {}", response.status());
+    println!("Headers:\n{:#?}", response.headers());
+
+    let body = response.text().await?;
+
+    println!("Body:\n{}", body);
+
+    Ok(())
+}
